## 4. Networking

<details>
<summary><strong>What is the difference between IPv4 and IPv6? Show IP with CLI.</strong></summary>

IPv4 uses 32‑bit addresses and provides about 4.3 billion unique addresses.
IPv6 uses 128‑bit addresses and provides a vastly larger address space, along with improvements such as built‑in security (IPsec) and more efficient routing.

```bash
ip -c a
```
</details>

<details>
<summary><strong>What is CIDR?</strong></summary>

CIDR (Classless Inter‑Domain Routing) is a method of allocating IP addresses and routing them using a prefix and subnet mask (for example, 192.168.1.0/24).
</details>

<details>
<summary><strong>What is a switch? Show the switch with CLI.</strong></summary>

A switch is a network device that connects devices within the same network and forwards data only to the destination device.

```bash
ip link
```
</details>

<details>
<summary><strong>What is the gateway? Show the gateway with CLI.</strong></summary>

A gateway is a network device (often a router) that routes traffic from a local network to external networks, such as the internet.
 
```bash
ip route or route -n
```
</details>

<details>
<summary><strong>What are DNS? Describe how they work.</strong></summary>

DNS (Domain Name System) translates human-readable domain names (like www.example.com) into IP addresses that computers use to communicate. When you access a website, your system queries a DNS server, which returns the corresponding IP address.
</details>

<details>
<summary><strong>What is the difference between /etc/resolv.conf and /etc/systemd/resolved.conf? resolvectl command which file change?</strong></summary>

/etc/resolv.conf is the traditional (old) file where DNS resolver settings (nameservers, search domains) are stored. On systems not using systemd‑resolved, you edit this file directly. On systems where systemd‑resolved is active, this file is usually autogenerated and should not be modified manually.

Check:
```bash
systemctl is-active systemd-resolved
ls -l /etc/resolv.conf   # is there symlink?
```

/etc/systemd/resolved.conf is the configuration file for systemd‑resolved, which manages DNS resolution on modern Linux systems. When systemd‑resolved is active, DNS servers should be configured here (or in drop‑in files under /etc/systemd/resolved.conf.d/) instead of editing /etc/resolv.conf directly.

When using systemd‑resolved, the resolvectl (or systemd‑resolve) command changes the settings handled by systemd‑resolved and does not directly edit /etc/resolv.conf.
</details>

<details>
<summary><strong>Up and down the switch</strong></summary>

```bash
ip link help
ip link set ens33 up
ip link set ens33 down
```
</details>

<details>
<summary><strong>Add ip 192.168.1.238 temporarily</strong></summary>

```bash
ip addr add 192.168.1.238/24 dev ens33
```
</details>

<details>
<summary><strong>Remove ip added previously</strong></summary>

```bash
ip addr del 192.168.1.10/24 dev ens33
```
</details>

<details>
<summary><strong>Add ip 192.168.1.238 permanently</strong></summary>

```bash
sudo cp /usr/share/doc/netplan/examples/static_multiaddress.yaml /etc/netplan/
cd /etc/netplan
mv static_multiaddress.yaml   01_static_multiaddress.yaml
mv 01-network-manager-all.yaml 99-network-manager-all.yaml
vim 01_static_multiaddress.yaml
```

```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    ens33: # change with your interface
     addresses:
       - 192.168.1.155/24  # change with your primary ip
       - 192.168.1.120/24 # change with your secondary ip
     routes:
       - to: default
         via: 192.168.1.1  # change with your gateway ip
```

```bash
sudo netplan get
sudo netplan try
sudo netplan apply
```
</details>

<details>
<summary><strong>Add 8.8.8.8 dns</strong></summary>

```bash
systemctl is-active systemd-resolved
ls -l /etc/resolv.conf   # is there symlink? 

vi /etc/systemd/resolved.conf
DNS=8.8.8.8
resolvectl dns
dig localhost or 127.0.0.1 # or localhost's ip
```
</details>

<details>
<summary><strong>Checking network services. Restart network.</strong></summary>

```bash
systemctl status systemd-networkd
systemctl restart systemd-networkd
ping 8.8.8.8
traceroute 8.8.8.8
```
</details>

<details>
<summary><strong>Why use bridge mode?</strong></summary>

In bridge mode, a VM or container is attached to a virtual bridge that is itself connected to the physical network interface.
From the perspective of the external network, the VM or container appears as if it were a separate physical machine: it gets its own IP address from the LAN (usually via DHCP) and can communicate directly with other hosts.

Why it's useful:
The VM or container behaves like a normal host on the LAN.

It can be reached by other devices without additional NAT or port forwarding.

Practical example (VM):
In KVM/libvirt you can create a bridge br0 bound to your physical interface (e.g., eth0) and attach the VM's network interface to br0.
Inside the VM, running ip addr will show an IP in the same subnet as other hosts on your network.

Practical example (container):
In Docker, the default network type is bridge, where containers get private IPs and NAT to the outside.
You can also create a custom bridge network:
```bash
docker network create -d bridge mybridge
docker run --network mybridge ...
```

All containers attached to mybridge can communicate with each other as if they were on the same virtual LAN.
</details>

<details>
<summary><strong>Why use bond mode?</strong></summary>

Bond mode (also called link aggregation) lets you combine two or more physical network interfaces into a single logical interface.
The goals can be:
Increased bandwidth (e.g., two 1 Gbps NICs → up to 2 Gbps, depending on configuration and switch support).

Redundancy/failover: if one interface fails, the other keeps the connection alive without downtime.

Why it's useful:
Higher network availability (high availability).

Potentially higher throughput when supported by the switch and proper mode (e.g., LACP).

Practical example:
On a Linux server with two NICs (eth0 and eth1), you can configure a bond bond0 in 802.3ad (LACP) mode:
```
auto bond0
iface bond0 inet static
  address 192.168.1.50
  netmask 255.255.255.0
  bond-mode 802.3ad
  bond-miimon 100
  bond-slaves eth0 eth1
```

The server will use bond0 as a single interface, and if one NIC goes down, the other continues to serve traffic.
</details>

<details>
<summary><strong>What is a squid proxy?</strong></summary>

Squid is a caching and forwarding HTTP proxy server. It reduces bandwidth usage and improves response times by caching frequently accessed web content and can also be used to filter or control web access.
</details>

<details>
<summary><strong>Exercise Bridge and Bond</strong></summary>

We have two different network scenarios. Read carefully and decide which network configuration you would use in each case. Draw your solution with app.diagrams.net first, then configure it on the VMs.

**Scenario 1**
You have 4 servers.

Each server will run multiple virtual machines that must communicate with the physical LAN without NAT.

What kind of network configuration will you apply on these servers?
 (Hint: think about Layer‑2 forwarding and connecting VMs directly to the LAN.)

**Scenario 2**
You have 4 other servers.

Each server has two physical NICs connected to the same switch.

The goal is to increase link redundancy and failover support, and possibly increase bandwidth.

What kind of network configuration will you apply on these servers?
 (Hint: think about combining multiple interfaces for resilience.)

**Tasks**
For each scenario, choose the correct configuration (bridge or bond) and explain why.
Use https://app.diagrams.net/ to draw the network topology for each scenario.
Configure the chosen mode on your VMs.
</details>

<details>
<summary><strong>What is Firewall?</strong></summary>

A firewall is a system or software that controls incoming and outgoing network traffic based on predefined security rules. It acts as a barrier between a trusted internal network and untrusted external networks (such as the internet), allowing or blocking traffic depending on the rules configured.
</details>

<details>
<summary><strong>What is a firewalld zone? What is a DMZ?</strong></summary>

A firewalld zone is a set of predefined firewall rules applied based on interface or source address (e.g., public, internal, trusted).

A DMZ (demilitarized zone) is a network segment where services accessible from outside are placed, with limited access to the internal network.
</details>

<details>
<summary><strong>What is NAT?</strong></summary>

NAT (Network Address Translation) is a method that modifies network address information in packet headers while in transit, enabling multiple devices on a private network to share a single public IP address
</details>

<details>
<summary><strong>What is port redirection?</strong></summary>

Port redirection (also called port forwarding) is the process of forwarding traffic from one port to another, often from an external port on a firewall or router to an internal port on a specific host. For example, redirecting traffic from port 80 on a public interface to port 8080 on a local server.
</details>

<details>
<summary><strong>What is masquerading ?</strong></summary>

Masquerading is a type of NAT commonly used when the gateway's public IP address can change, for example on a dynamic internet connection.
With masquerading, the source IP address of outgoing packets is replaced with the current public IP of the gateway.
The gateway also tracks each connection, so when the response packets come back, it knows which internal device they belong to and forwards them correctly.
</details>

<details>
<summary><strong>See status of firewalld. Start and enable is needed.</strong></summary>

```bash
systemctl status firewalld
systemctl start firewalld
systemctl enable --now firewalld
```
</details>

<details>
<summary><strong>Allow ssh service and open port 80 in permanent mode. Check all ports open.</strong></summary>

```bash
firewall-cmd --add-service=ssh --permanent
firewall-cmd --reload
firewall-cmd --add-port=80/tcp --permanent
firewall-cmd --reload
firewall-cmd --list-ports
```
</details>

<details>
<summary><strong>Check all list (services, ports and ecc). Remove port 80 in permanent mode.</strong></summary>

```bash
firewall-cmd --list-all
firewall-cmd --remove-port=80/tcp --permanent
firewall-cmd --reload
firewall-cmd --list-ports
```
</details>

<details>
<summary><strong>Enable ip forwarding</strong></summary>

```bash
echo 'net.ipv4.ip_forward = 1' > /etc/sysctl.d/net_ipv_.ip_forward.conf
sysctl -p /etc/sysctl.d/net_ipv_.ip_forward.conf
sysctl -a | grep ip_forward
```
</details>

<details>
<summary><strong>What is iptables and what problem does it solve?</strong></summary>

iptables is a userspace utility to configure the Linux kernel firewall.
It filters network packets, performs NAT, and controls network traffic flow by applying rules in different tables and chains.
</details>

<details>
<summary><strong>What are tables in iptables (filter, nat, mangle, raw, security) and what are they used for?</strong></summary>

**filter**: Default table, used for packet filtering (ACCEPT, DROP, etc.).

**nat**: Used for network address translation (SNAT, DNAT, MASQUERADE, REDIRECT).

**mangle**: Used for specialized packet alteration (marking packets, changing TOS).

**raw**: Used to configure packets exempt from connection tracking.

**security**: Used for mandatory access control systems (SELinux, AppArmor).
</details>

<details>
<summary><strong>What are chains (INPUT, OUTPUT, FORWARD, PREROUTING, POSTROUTING) and in which situations are they triggered?</strong></summary>

**INPUT**: For packets destined to the local system.

**OUTPUT**: For packets generated by the local system.

**FORWARD**: For packets routed through the system (from one interface to another).

**PREROUTING**: Alters packets as soon as they arrive (before routing). Used in nat for DNAT or REDIRECT.

**POSTROUTING**: Alters packets before they leave the system (after routing). Used in nat for SNAT or MASQUERADE.
</details>

<details>
<summary><strong>How does the packet flow through the different tables and chains?</strong></summary>

A packet arriving from the network first hits PREROUTING (raw → mangle → nat), then gets routed:
If destined locally → goes to INPUT (mangle → filter).

If forwarded → goes to FORWARD (mangle → filter).

Locally generated packets go through OUTPUT (raw → mangle → nat → filter).
 Finally, all outgoing packets pass POSTROUTING (mangle → nat).

Important: PREROUTING and POSTROUTING rules are in the nat table.
They are not visible with iptables -L -n (which shows only the filter table).
To see them, use:
```bash
iptables -t nat -L -n
```
</details>

<details>
<summary><strong>How do you add a rule? How do you delete or modify it?</strong></summary>

Add: 
```bash
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
```

Delete: 
```bash
iptables -D INPUT -p tcp --dport 22 -j ACCEPT
```

Insert at position: 
```bash
iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT
```
</details>

<details>
<summary><strong>What is the difference between -A (append), -I (insert) and -R (replace)?</strong></summary>

**-A**: Appends a rule at the end of the chain.

**-I**: Inserts a rule at a specific position (default position 1).

**-R**: Replaces an existing rule at a given position.
</details>

<details>
<summary><strong>How do you specify a source IP, destination IP, protocol, or port in a rule?</strong></summary>

Example:
```bash
iptables -A INPUT -p tcp -s 192.168.1.10 --dport 80 -j ACCEPT
```
Here: -s = source IP, --dport = destination port, -p = protocol.
</details>

<details>
<summary><strong>What is the difference between ACCEPT, DROP, REJECT, and LOG targets?</strong></summary>

**ACCEPT**: Allow the packet.

**DROP**: Silently discard the packet.

**REJECT**: Discard and send an error response (e.g., ICMP unreachable or TCP reset).

**LOG**: Log the packet but continue processing the chain.
</details>

<details>
<summary><strong>How do you list all rules and see their order and counters?</strong></summary>

```bash
iptables -L -v -n (filter table)
iptables -t nat -L -v -n (nat table)
```
</details>

<details>
<summary><strong>How do you implement a simple DNAT (port forwarding) rule?</strong></summary>

Forward external port 8080 to internal 192.168.1.100:80:
```bash
iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.100:80
```
Enable forwarding and allow in the FORWARD chain.
</details>

<details>
<summary><strong>How do you implement a REDIRECT rule (redirect to a local port)?</strong></summary>

Redirect all TCP traffic on port 6000 to local port 6001:
```bash
iptables -t nat -A PREROUTING -p tcp --dport 6000 -j REDIRECT --to-port 6001
```
</details>

<details>
<summary><strong>How do you configure masquerading for a private network?</strong></summary>

Example (assuming eth0 is WAN):
```bash
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
```
</details>

<details>
<summary><strong>What is the difference between SNAT and MASQUERADE?</strong></summary>

**SNAT**: Static source NAT, used with a known fixed public IP.

**MASQUERADE**: Dynamic source NAT, used when the public IP is dynamic (common on home connections).
</details>

<details>
<summary><strong>In which chain do you configure DNAT, REDIRECT or SNAT/MASQUERADE?</strong></summary>

**DNAT and REDIRECT**: in PREROUTING (nat table).

**SNAT/MASQUERADE**: in POSTROUTING (nat table).
</details>

<details>
<summary><strong>Are iptables rules persistent after a reboot?</strong></summary>

No, by default they are not persistent. You must save them with iptables-save and restore with iptables-restore, or use netfilter-persistent or distribution-specific mechanisms.
</details>

<details>
<summary><strong>How do you save and restore iptables rules?</strong></summary>

Save: 
```bash
iptables-save > /etc/iptables/rules.v4
```

Restore: 
```bash
iptables-restore < /etc/iptables/rules.v4
```
</details>

<details>
<summary><strong>What are the differences between iptables and nftables?</strong></summary>

nftables is the newer, unified packet filtering framework, replacing multiple tools (iptables, ip6tables, arptables, ebtables).
It has better performance, simpler syntax, and more features.
</details>

<details>
<summary><strong>How do you log packets that match a rule without dropping them?</strong></summary>

```bash
iptables -A INPUT -p tcp --dport 22 -j LOG --log-prefix "SSH attempt: "
```
</details>

<details>
<summary><strong>How do you test a rule before applying it to production?</strong></summary>

Apply it temporarily or in a test environment. You can also use iptables -C to check if a packet would match a rule.
</details>

<details>
<summary><strong>What is the impact of rule order on packet processing?</strong></summary>

Rules are evaluated in order within a chain. The first matching rule that decides a fate (ACCEPT/DROP/REJECT) stops further evaluation.
</details>

<details>
<summary><strong>How do you combine iptables with fail2ban or other security tools?</strong></summary>

fail2ban dynamically adds and removes iptables rules to block IPs showing malicious behavior (e.g., repeated failed logins).
</details>

<details>
<summary><strong>Port 5000 should be closed</strong></summary>

```bash
iptables -A INPUT -p tcp --dport 5000 -j DROP
```
</details>

<details>
<summary><strong>Redirect all traffic on port 6000 to local port 6001</strong></summary>

```bash
iptables -t nat -A PREROUTING -p tcp --dport 6000 -j REDIRECT --to-port 6001
```
</details>

<details>
<summary><strong>Port 6002 should only be accessible from IP 192.168.10.80</strong></summary>

```bash
iptables -A INPUT -p tcp --dport 6002 -s 192.168.10.80 -j ACCEPT
iptables -A INPUT -p tcp --dport 6002 -j DROP
```
</details>

<details>
<summary><strong>Block all outgoing traffic to IP 192.168.10.70</strong></summary>

```bash
iptables -A OUTPUT -d 192.168.10.70 -j DROP
```
</details>

<details>
<summary><strong>Port 8080 should be closed</strong></summary>

```bash
iptables -A INPUT -p tcp --dport 8080 -j DROP
```
</details>

<details>
<summary><strong>Redirect all traffic arriving on port 2222 to local port 22</strong></summary>

```bash
iptables -t nat -A PREROUTING -p tcp --dport 2222 -j REDIRECT --to-port 22
```
</details>

<details>
<summary><strong>Port 3306 should only be accessible from IP 10.0.0.50</strong></summary>

```bash
iptables -A INPUT -p tcp --dport 3306 -s 10.0.0.50 -j ACCEPT
iptables -A INPUT -p tcp --dport 3306 -j DROP
```
</details>

<details>
<summary><strong>Block all outgoing traffic to IP 10.0.0.99</strong></summary>

```bash
iptables -A OUTPUT -d 10.0.0.99 -j DROP
```
</details>

<details>
<summary><strong>Redirect all incoming traffic on port 8081 to internal host 192.168.1.50 port 80</strong></summary>

```bash
iptables -t nat -A PREROUTING -p tcp --dport 8081 -j DNAT --to-destination 192.168.1.50:80
iptables -A FORWARD -p tcp -d 192.168.1.50 --dport 80 -j ACCEPT
```
</details>

<details>
<summary><strong>Masquerade all outgoing traffic on interface eth1</strong></summary>

```bash
iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE
```
</details>

<details>
<summary><strong>Port 9000 should be open only for subnet 192.168.50.0/24</strong></summary>

```bash
iptables -A INPUT -p tcp --dport 9000 -s 192.168.50.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 9000 -j DROP
```
</details>

<details>
<summary><strong>Allow only SSH (port 22) from IP 203.0.113.10 and block others</strong></summary>

```bash
iptables -A INPUT -p tcp --dport 22 -s 203.0.113.10 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j DROP
```
</details>

<details>
<summary><strong>Drop all incoming ICMP echo-requests (ping) from 10.1.1.0/24</strong></summary>

```bash
iptables -A INPUT -p icmp --icmp-type echo-request -s 10.1.1.0/24 -j DROP
```
</details>

<details>
<summary><strong>Allow outgoing HTTP (port 80) but log every attempt to port 21 (FTP) before dropping it</strong></summary>

```bash
iptables -A OUTPUT -p tcp --dport 80 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 21 -j LOG --log-prefix "FTP attempt: "
iptables -A OUTPUT -p tcp --dport 21 -j DROP
```
</details>

<details>
<summary><strong>What is a reverse proxy?</strong></summary>

A reverse proxy is a server that sits in front of one or more backend servers and forwards client requests to them. It hides the identity of the backend servers, can provide SSL termination, caching, compression, authentication, and can improve security by controlling access to the backend infrastructure.
</details>

<details>
<summary><strong>What is a load balancer?</strong></summary>

A load balancer is a system or device that distributes incoming network or application traffic across multiple servers. Its goal is to ensure no single server becomes overwhelmed, to improve responsiveness, increase availability, and provide fault tolerance.
</details>

<details>
<summary><strong>Exercise - Load Balancer</strong></summary>

Set up three backend web servers and one Nginx load balancer. Verify that requests are distributed across the backends.

**Environment**
Backend servers:
 192.168.1.101 (backend1)
 192.168.1.102 (backend2)
 192.168.1.103 (backend3)

Load balancer server:
 192.168.1.10

**Requirements**
Install and configure Apache on each backend with a unique page.

Install and configure Nginx on the load balancer as a reverse proxy with round‑robin load balancing.

Verify that requests to the load balancer are distributed to all backends.

**Steps**
1. Configure backend servers
On each backend:
```bash
sudo apt update
sudo apt install apache2 -y
```

Create a unique index page per backend, for example on backend1:
```bash
echo "<html><body><h1>This is backend1</h1></body></html>" | sudo tee /var/www/html/index.html
```
(Change the text on backend2 and backend3 accordingly.)
Restart Apache if necessary.

2. Configure the load balancer
On the load balancer server, install Nginx and configure it as a reverse proxy with round‑robin load balancing.
 Ensure that it proxies requests to all three backend servers.

3. Verification
Once configured, test by sending multiple HTTP requests to the load balancer and verify that responses are served alternately by backend1, backend2, and backend3.
</details>

<details>
<summary><strong>What is NTP?</strong></summary>

NTP (Network Time Protocol) is a protocol used to synchronize the clocks of computers and devices over a network. It ensures that all systems maintain accurate and consistent time, which is critical for logging, security, and time-sensitive operations.
</details>

<details>
<summary><strong>List all timezones</strong></summary>

```bash
timedatectl list-zones
```
</details>

<details>
<summary><strong>Set timezone Europe/Rome</strong></summary>

```bash
timedatectl set-timezone Europe/Rome
```
</details>

<details>
<summary><strong>Time synchronisation configuration needs to be updated:</strong></summary>

Set 0.pool.ntp.org and 1.pool.ntp.org as main NTP servers
Set ntp.ubuntu.com and 0.debian.pool.ntp.org as fallback NTP servers
The maximum poll interval should be 1000 seconds and the connection retry 20 seconds

```bash
vi /etc/systemd/timesyncd.conf
```

```ini
[Time]
NTP=0.pool.ntp.org 1.pool.ntp.org
FallbackNTP=ntp.ubuntu.com 0.debian.pool.ntp.org
#RootDistanceMaxSec=5
#PollIntervalMinSec=32
PollIntervalMaxSec=1000
```
</details>

<details>
<summary><strong>What is SSH? What is 'challenge and response'?</strong></summary>

SSH (Secure Shell) is a protocol used to securely access and manage remote systems over an unsecured network. It provides encrypted communication, authentication, and integrity checks, typically used for remote login (e.g., ssh user@host) and secure file transfers (scp, sftp).

Challenge and response is an authentication method where the server sends a challenge (such as a question, a code, or a cryptographic value) to the client, and the client must provide the correct response. The response often depends on a shared secret or a key. This mechanism is used to verify identity without directly transmitting passwords in clear text. For example, some multi-factor authentication systems or hardware tokens use challenge–response to enhance security.
</details>

<details>
<summary><strong>Generate ssh keys</strong></summary>

```bash
ssh-keygen
```
</details>

<details>
<summary><strong>Copy ssh keys on the servers for user authentication</strong></summary>

```bash
ssh-copy-id user@192.168.1.x
```
</details>

<details>
<summary><strong>Change ssh configuration and deny the Password Authentication</strong></summary>

```bash
vi /etc/ssh/ssh_config
PasswordAuthentication no
```
</details>